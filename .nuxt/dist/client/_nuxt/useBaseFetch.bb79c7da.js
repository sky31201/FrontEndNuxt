import{r as D,y as k,a2 as C,A as b,B as O,a3 as P,u as g,a4 as R,a5 as B,a6 as E,C as F,q as $,i as L}from"./entry.f14e2a09.js";import{u as A}from"./loadingStore.a2673919.js";const M=()=>null;function S(...o){const f=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(f);let[t,n,a={}]=o;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof n!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");a.server=a.server??!0,a.default=a.default??M,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0;const e=P(),y=()=>e.isHydrating?e.payload.data[t]:e.static.data[t],c=()=>y()!==void 0;e._asyncData[t]||(e._asyncData[t]={data:D(y()??a.default()),pending:D(!c()),error:k(e.payload._errors,t),status:D("idle")});const s={...e._asyncData[t]};s.refresh=s.execute=(i={})=>{if(e._asyncDataPromises[t]){if(i.dedupe===!1)return e._asyncDataPromises[t];e._asyncDataPromises[t].cancelled=!0}if((i._initial||e.isHydrating&&i._initial!==!1)&&c())return y();s.pending.value=!0,s.status.value="pending";const l=new Promise((r,u)=>{try{r(n(e))}catch(v){u(v)}}).then(r=>{if(l.cancelled)return e._asyncDataPromises[t];let u=r;a.transform&&(u=a.transform(r)),a.pick&&(u=T(u,a.pick)),s.data.value=u,s.error.value=null,s.status.value="success"}).catch(r=>{if(l.cancelled)return e._asyncDataPromises[t];s.error.value=r,s.data.value=g(a.default()),s.status.value="error"}).finally(()=>{l.cancelled||(s.pending.value=!1,e.payload.data[t]=s.data.value,s.error.value&&(e.payload._errors[t]=R(s.error.value)),delete e._asyncDataPromises[t])});return e._asyncDataPromises[t]=l,e._asyncDataPromises[t]};const p=()=>s.refresh({_initial:!0}),_=a.server!==!1&&e.payload.serverRendered;{const i=B();if(i&&!i._nuxtOnBeforeMountCbs){i._nuxtOnBeforeMountCbs=[];const r=i._nuxtOnBeforeMountCbs;i&&(C(()=>{r.forEach(u=>{u()}),r.splice(0,r.length)}),b(()=>r.splice(0,r.length)))}_&&e.isHydrating&&c()?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):i&&(e.payload.serverRendered&&e.isHydrating||a.lazy)&&a.immediate?i._nuxtOnBeforeMountCbs.push(p):a.immediate&&p(),a.watch&&O(a.watch,()=>s.refresh());const l=e.hook("app:data:refresh",r=>{if(!r||r.includes(t))return s.refresh()});i&&b(l)}const m=Promise.resolve(e._asyncDataPromises[t]).then(()=>s);return Object.assign(m,s),m}function T(o,f){const t={};for(const n of f)t[n]=o[n];return t}function U(o,f,t){const[n={},a]=typeof f=="string"?[{},f]:[f,t],e=n.key||E([a,g(n.baseURL),typeof o=="string"?o:"",g(n.params||n.query)]);if(!e||typeof e!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+e);if(!o)throw new Error("[nuxt] [useFetch] request is missing.");const y=e===a?"$f"+e:e,c=F(()=>{let h=o;return typeof h=="function"&&(h=h()),g(h)});if(!n.baseURL&&typeof c.value=="string"&&c.value.startsWith("//"))throw new Error('[nuxt] [useFetch] the request URL must not start with "//".');const{server:s,lazy:p,default:_,transform:m,pick:i,watch:l,immediate:r,...u}=n,v=$({...u,cache:typeof n.cache=="boolean"?void 0:n.cache}),x={server:s,lazy:p,default:_,transform:m,pick:i,immediate:r,watch:l===!1?[]:[v,c,...l||[]]};let d;return S(y,()=>{var w;return(w=d==null?void 0:d.abort)==null||w.call(d),d=typeof AbortController<"u"?new AbortController:{},typeof c.value=="string"&&c.value.startsWith("/"),(n.$fetch||globalThis.$fetch)(c.value,{signal:d.signal,...v})},x)}const q=(o,f)=>{const{$pinia:t}=P(),n=A(t);return U(o,{baseURL:L().public.apiBase,method:"POST",onRequestError(a){n.setLoadingShow(!1),console.log(a)},...f},"$8IdNXPyjgv")};export{q as u};
